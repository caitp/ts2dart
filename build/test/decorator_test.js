/// <reference path="../typings/mocha/mocha.d.ts"/>
var test_support_1 = require('./test_support');
describe('decorators', function () {
    it('translates plain decorators', function () { test_support_1.expectTranslate('@A class X {}').to.equal(' @ A class X { }'); });
    it('translates arguments', function () { test_support_1.expectTranslate('@A(a, b) class X {}').to.equal(' @ A ( a , b ) class X { }'); });
    it('translates const arguments', function () {
        test_support_1.expectTranslate('@A([1]) class X {}').to.equal(' @ A ( const [ 1 ] ) class X { }');
        test_support_1.expectTranslate('@A({"a": 1}) class X {}').to.equal(' @ A ( const { "a" : 1 } ) class X { }');
        test_support_1.expectTranslate('@A(new B()) class X {}').to.equal(' @ A ( const B ( ) ) class X { }');
    });
    it('translates on functions', function () { test_support_1.expectTranslate('@A function f() {}').to.equal(' @ A f ( ) { }'); });
    it('translates on properties', function () { test_support_1.expectTranslate('class X { @A p; }').to.equal(' class X { @ A var p ; }'); });
    it('translates on parameters', function () { test_support_1.expectTranslate('function f (@A p) {}').to.equal(' f ( @ A p ) { }'); });
    it('special cases @CONST', function () {
        test_support_1.expectTranslate('@CONST class X {}').to.equal(' class X { const X (); }');
        test_support_1.expectTranslate('@CONST() class X {}').to.equal(' class X { const X (); }');
        test_support_1.expectTranslate("@CONST class X {\n                       x: number;\n                       y;\n                       constructor() { super(3); this.x = 1; this.y = 2; }\n                     }")
            .to.equal(' class X {' +
            ' final num x ; final y ;' +
            ' const X ( ) : x = 1 , y = 2 , super ( 3 ) ; }');
        // @CONST constructors.
        test_support_1.expectTranslate('@CONST class X { constructor() {} }').to.equal(' class X { const X ( ) ; }');
        // For backwards-compatibility for traceur inputs (not valid TS input)
        test_support_1.expectTranslate('class X { @CONST constructor() {} }').to.equal(' class X { const X ( ) ; }');
        test_support_1.expectErroneousCode('@CONST class X { constructor() { if (1); } }')
            .to.throw('const constructors can only contain assignments and super calls');
        test_support_1.expectErroneousCode('@CONST class X { constructor() { f(); } }')
            .to.throw('const constructors can only contain assignments and super calls');
        test_support_1.expectErroneousCode('@CONST class X { constructor() { "string literal"; } }')
            .to.throw('const constructors can only contain assignments and super calls');
        test_support_1.expectErroneousCode('class X { @CONST constructor() { x = 1; } }')
            .to.throw('assignments in const constructors must assign into this.');
        test_support_1.expectErroneousCode('class X { @CONST constructor() { thax = 1; } }')
            .to.throw('assignments in const constructors must assign into this.');
        // @CONST properties.
        test_support_1.expectTranslate('class Foo { @CONST() static foo = 1; }')
            .to.equal(' class Foo { static const foo = 1 ; }');
    });
    it('special cases @ABSTRACT', function () { test_support_1.expectTranslate('@ABSTRACT class X {}').to.equal(' abstract class X { }'); });
    it('special cases @IMPLEMENTS', function () {
        test_support_1.expectTranslate('@IMPLEMENTS(Y, Z) class X {}').to.equal(' class X implements Y , Z { }');
        test_support_1.expectTranslate('@IMPLEMENTS(Z) class X extends Y {}')
            .to.equal(' class X extends Y implements Z { }');
        test_support_1.expectTranslate('@IMPLEMENTS(Z) class X implements Y {}')
            .to.equal(' class X implements Y , Z { }');
    });
});

//# sourceMappingURL=data:application/json;base64,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QXFCO1FBQ3JCLDhCQUFlLENBQUMsd0NBQXdDLENBQUM7YUFDcEQsRUFBRSxDQUFDLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO0lBQ3pELENBQUMsQ0FBQyxDQUFDO0lBQ0gsRUFBRSxDQUFDLHlCQUF5QixFQUN6QixjQUFRLDhCQUFlLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN6RixFQUFFLENBQUMsMkJBQTJCLEVBQUU7UUFDOUIsOEJBQWUsQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsK0JBQStCLENBQUMsQ0FBQztRQUMxRiw4QkFBZSxDQUFDLHFDQUFxQyxDQUFDO2FBQ2pELEVBQUUsQ0FBQyxLQUFLLENBQUMscUNBQXFDLENBQUMsQ0FBQztRQUNyRCw4QkFBZSxDQUFDLHdDQUF3QyxDQUFDO2FBQ3BELEVBQUUsQ0FBQyxLQUFLLENBQUMsK0JBQStCLENBQUMsQ0FBQztJQUNqRCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwiZmlsZSI6InRlc3QvZGVjb3JhdG9yX3Rlc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vdHlwaW5ncy9tb2NoYS9tb2NoYS5kLnRzXCIvPlxuaW1wb3J0IHtleHBlY3RUcmFuc2xhdGUsIGV4cGVjdEVycm9uZW91c0NvZGV9IGZyb20gJy4vdGVzdF9zdXBwb3J0JztcblxuZGVzY3JpYmUoJ2RlY29yYXRvcnMnLCAoKSA9PiB7XG4gIGl0KCd0cmFuc2xhdGVzIHBsYWluIGRlY29yYXRvcnMnLFxuICAgICAoKSA9PiB7IGV4cGVjdFRyYW5zbGF0ZSgnQEEgY2xhc3MgWCB7fScpLnRvLmVxdWFsKCcgQCBBIGNsYXNzIFggeyB9Jyk7IH0pO1xuICBpdCgndHJhbnNsYXRlcyBhcmd1bWVudHMnLFxuICAgICAoKSA9PiB7IGV4cGVjdFRyYW5zbGF0ZSgnQEEoYSwgYikgY2xhc3MgWCB7fScpLnRvLmVxdWFsKCcgQCBBICggYSAsIGIgKSBjbGFzcyBYIHsgfScpOyB9KTtcbiAgaXQoJ3RyYW5zbGF0ZXMgY29uc3QgYXJndW1lbnRzJywgKCkgPT4ge1xuICAgIGV4cGVjdFRyYW5zbGF0ZSgnQEEoWzFdKSBjbGFzcyBYIHt9JykudG8uZXF1YWwoJyBAIEEgKCBjb25zdCBbIDEgXSApIGNsYXNzIFggeyB9Jyk7XG4gICAgZXhwZWN0VHJhbnNsYXRlKCdAQSh7XCJhXCI6IDF9KSBjbGFzcyBYIHt9JykudG8uZXF1YWwoJyBAIEEgKCBjb25zdCB7IFwiYVwiIDogMSB9ICkgY2xhc3MgWCB7IH0nKTtcbiAgICBleHBlY3RUcmFuc2xhdGUoJ0BBKG5ldyBCKCkpIGNsYXNzIFgge30nKS50by5lcXVhbCgnIEAgQSAoIGNvbnN0IEIgKCApICkgY2xhc3MgWCB7IH0nKTtcbiAgfSk7XG4gIGl0KCd0cmFuc2xhdGVzIG9uIGZ1bmN0aW9ucycsXG4gICAgICgpID0+IHsgZXhwZWN0VHJhbnNsYXRlKCdAQSBmdW5jdGlvbiBmKCkge30nKS50by5lcXVhbCgnIEAgQSBmICggKSB7IH0nKTsgfSk7XG4gIGl0KCd0cmFuc2xhdGVzIG9uIHByb3BlcnRpZXMnLFxuICAgICAoKSA9PiB7IGV4cGVjdFRyYW5zbGF0ZSgnY2xhc3MgWCB7IEBBIHA7IH0nKS50by5lcXVhbCgnIGNsYXNzIFggeyBAIEEgdmFyIHAgOyB9Jyk7IH0pO1xuICBpdCgndHJhbnNsYXRlcyBvbiBwYXJhbWV0ZXJzJyxcbiAgICAgKCkgPT4geyBleHBlY3RUcmFuc2xhdGUoJ2Z1bmN0aW9uIGYgKEBBIHApIHt9JykudG8uZXF1YWwoJyBmICggQCBBIHAgKSB7IH0nKTsgfSk7XG4gIGl0KCdzcGVjaWFsIGNhc2VzIEBDT05TVCcsICgpID0+IHtcbiAgICBleHBlY3RUcmFuc2xhdGUoJ0BDT05TVCBjbGFzcyBYIHt9JykudG8uZXF1YWwoJyBjbGFzcyBYIHsgY29uc3QgWCAoKTsgfScpO1xuICAgIGV4cGVjdFRyYW5zbGF0ZSgnQENPTlNUKCkgY2xhc3MgWCB7fScpLnRvLmVxdWFsKCcgY2xhc3MgWCB7IGNvbnN0IFggKCk7IH0nKTtcbiAgICBleHBlY3RUcmFuc2xhdGUoYEBDT05TVCBjbGFzcyBYIHtcbiAgICAgICAgICAgICAgICAgICAgICAgeDogbnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICB5O1xuICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHsgc3VwZXIoMyk7IHRoaXMueCA9IDE7IHRoaXMueSA9IDI7IH1cbiAgICAgICAgICAgICAgICAgICAgIH1gKVxuICAgICAgICAudG8uZXF1YWwoJyBjbGFzcyBYIHsnICtcbiAgICAgICAgICAgICAgICAgICcgZmluYWwgbnVtIHggOyBmaW5hbCB5IDsnICtcbiAgICAgICAgICAgICAgICAgICcgY29uc3QgWCAoICkgOiB4ID0gMSAsIHkgPSAyICwgc3VwZXIgKCAzICkgOyB9Jyk7XG5cbiAgICAvLyBAQ09OU1QgY29uc3RydWN0b3JzLlxuICAgIGV4cGVjdFRyYW5zbGF0ZSgnQENPTlNUIGNsYXNzIFggeyBjb25zdHJ1Y3RvcigpIHt9IH0nKS50by5lcXVhbCgnIGNsYXNzIFggeyBjb25zdCBYICggKSA7IH0nKTtcbiAgICAvLyBGb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRyYWNldXIgaW5wdXRzIChub3QgdmFsaWQgVFMgaW5wdXQpXG4gICAgZXhwZWN0VHJhbnNsYXRlKCdjbGFzcyBYIHsgQENPTlNUIGNvbnN0cnVjdG9yKCkge30gfScpLnRvLmVxdWFsKCcgY2xhc3MgWCB7IGNvbnN0IFggKCApIDsgfScpO1xuICAgIGV4cGVjdEVycm9uZW91c0NvZGUoJ0BDT05TVCBjbGFzcyBYIHsgY29uc3RydWN0b3IoKSB7IGlmICgxKTsgfSB9JylcbiAgICAgICAgLnRvLnRocm93KCdjb25zdCBjb25zdHJ1Y3RvcnMgY2FuIG9ubHkgY29udGFpbiBhc3NpZ25tZW50cyBhbmQgc3VwZXIgY2FsbHMnKTtcbiAgICBleHBlY3RFcnJvbmVvdXNDb2RlKCdAQ09OU1QgY2xhc3MgWCB7IGNvbnN0cnVjdG9yKCkgeyBmKCk7IH0gfScpXG4gICAgICAgIC50by50aHJvdygnY29uc3QgY29uc3RydWN0b3JzIGNhbiBvbmx5IGNvbnRhaW4gYXNzaWdubWVudHMgYW5kIHN1cGVyIGNhbGxzJyk7XG4gICAgZXhwZWN0RXJyb25lb3VzQ29kZSgnQENPTlNUIGNsYXNzIFggeyBjb25zdHJ1Y3RvcigpIHsgXCJzdHJpbmcgbGl0ZXJhbFwiOyB9IH0nKVxuICAgICAgICAudG8udGhyb3coJ2NvbnN0IGNvbnN0cnVjdG9ycyBjYW4gb25seSBjb250YWluIGFzc2lnbm1lbnRzIGFuZCBzdXBlciBjYWxscycpO1xuICAgIGV4cGVjdEVycm9uZW91c0NvZGUoJ2NsYXNzIFggeyBAQ09OU1QgY29uc3RydWN0b3IoKSB7IHggPSAxOyB9IH0nKVxuICAgICAgICAudG8udGhyb3coJ2Fzc2lnbm1lbnRzIGluIGNvbnN0IGNvbnN0cnVjdG9ycyBtdXN0IGFzc2lnbiBpbnRvIHRoaXMuJyk7XG4gICAgZXhwZWN0RXJyb25lb3VzQ29kZSgnY2xhc3MgWCB7IEBDT05TVCBjb25zdHJ1Y3RvcigpIHsgdGhheCA9IDE7IH0gfScpXG4gICAgICAgIC50by50aHJvdygnYXNzaWdubWVudHMgaW4gY29uc3QgY29uc3RydWN0b3JzIG11c3QgYXNzaWduIGludG8gdGhpcy4nKTtcblxuICAgIC8vIEBDT05TVCBwcm9wZXJ0aWVzLlxuICAgIGV4cGVjdFRyYW5zbGF0ZSgnY2xhc3MgRm9vIHsgQENPTlNUKCkgc3RhdGljIGZvbyA9IDE7IH0nKVxuICAgICAgICAudG8uZXF1YWwoJyBjbGFzcyBGb28geyBzdGF0aWMgY29uc3QgZm9vID0gMSA7IH0nKTtcbiAgfSk7XG4gIGl0KCdzcGVjaWFsIGNhc2VzIEBBQlNUUkFDVCcsXG4gICAgICgpID0+IHsgZXhwZWN0VHJhbnNsYXRlKCdAQUJTVFJBQ1QgY2xhc3MgWCB7fScpLnRvLmVxdWFsKCcgYWJzdHJhY3QgY2xhc3MgWCB7IH0nKTsgfSk7XG4gIGl0KCdzcGVjaWFsIGNhc2VzIEBJTVBMRU1FTlRTJywgKCkgPT4ge1xuICAgIGV4cGVjdFRyYW5zbGF0ZSgnQElNUExFTUVOVFMoWSwgWikgY2xhc3MgWCB7fScpLnRvLmVxdWFsKCcgY2xhc3MgWCBpbXBsZW1lbnRzIFkgLCBaIHsgfScpO1xuICAgIGV4cGVjdFRyYW5zbGF0ZSgnQElNUExFTUVOVFMoWikgY2xhc3MgWCBleHRlbmRzIFkge30nKVxuICAgICAgICAudG8uZXF1YWwoJyBjbGFzcyBYIGV4dGVuZHMgWSBpbXBsZW1lbnRzIFogeyB9Jyk7XG4gICAgZXhwZWN0VHJhbnNsYXRlKCdASU1QTEVNRU5UUyhaKSBjbGFzcyBYIGltcGxlbWVudHMgWSB7fScpXG4gICAgICAgIC50by5lcXVhbCgnIGNsYXNzIFggaW1wbGVtZW50cyBZICwgWiB7IH0nKTtcbiAgfSk7XG59KTtcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==