{"version":3,"sources":["type.ts"],"names":["TypeTranspiler","TypeTranspiler.constructor","TypeTranspiler.visitNode"],"mappings":"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","file":"type.js","sourcesContent":["/// <reference path='../node_modules/typescript/bin/typescript.d.ts' />\nimport ts = require('typescript');\nimport base = require('./base');\nimport ts2dart = require('./main');\nimport {FacadeConverter} from './facade_converter';\n\nclass TypeTranspiler extends base.TranspilerBase {\n  constructor(tr: ts2dart.Transpiler, private fc: FacadeConverter) { super(tr); }\n\n  visitNode(node: ts.Node): boolean {\n    switch (node.kind) {\n      case ts.SyntaxKind.TypeLiteral:\n        // Dart doesn't support type literals.\n        this.emit('dynamic');\n        break;\n      case ts.SyntaxKind.UnionType:\n        this.emit('dynamic /*');\n        this.visitList((<ts.UnionTypeNode>node).types, \"|\");\n        this.emit('*/');\n        break;\n      case ts.SyntaxKind.TypeReference:\n        var typeRef = <ts.TypeReferenceNode>node;\n        this.fc.visitTypeName(typeRef.typeName);\n        this.maybeVisitTypeArguments(typeRef);\n        break;\n      case ts.SyntaxKind.TypeAssertionExpression:\n        var typeAssertExpr = <ts.TypeAssertion>node;\n        this.emit('(');\n        this.visit(typeAssertExpr.expression);\n        this.emit('as');\n        this.visit(typeAssertExpr.type);\n        this.emit(')');\n        break;\n      case ts.SyntaxKind.TypeParameter:\n        var typeParam = <ts.TypeParameterDeclaration>node;\n        this.visit(typeParam.name);\n        if (typeParam.constraint) {\n          this.emit('extends');\n          this.visit(typeParam.constraint);\n        }\n        break;\n      case ts.SyntaxKind.ArrayType:\n        this.emit('List');\n        this.emit('<');\n        this.visit((<ts.ArrayTypeNode>node).elementType);\n        this.emit('>');\n        break;\n      case ts.SyntaxKind.FunctionType:\n        this.emit('dynamic /*');\n        this.emit(node.getText());\n        this.emit('*/');\n        break;\n      case ts.SyntaxKind.QualifiedName:\n        var first = <ts.QualifiedName>node;\n        this.visit(first.left);\n        this.emit('.');\n        this.visit(first.right);\n        break;\n      case ts.SyntaxKind.Identifier:\n        var ident = <ts.Identifier>node;\n        this.emit(ident.text);\n        break;\n      case ts.SyntaxKind.NumberKeyword:\n        this.emit('num');\n        break;\n      case ts.SyntaxKind.StringKeyword:\n        this.emit('String');\n        break;\n      case ts.SyntaxKind.VoidKeyword:\n        this.emit('void');\n        break;\n      case ts.SyntaxKind.BooleanKeyword:\n        this.emit('bool');\n        break;\n      case ts.SyntaxKind.AnyKeyword:\n        this.emit('dynamic');\n        break;\n      default:\n        return false;\n    }\n    return true;\n  }\n}\n\nexport = TypeTranspiler;\n"],"sourceRoot":"/source/"}