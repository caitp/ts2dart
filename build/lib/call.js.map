{"version":3,"sources":["call.ts"],"names":["CallTranspiler","CallTranspiler.constructor","CallTranspiler.visitNode","CallTranspiler.visitCall","CallTranspiler.isInsideConstExpr","CallTranspiler.isConstCall","CallTranspiler.handleNamedParamsCall","CallTranspiler.visitConstructorBody","CallTranspiler.maybeHandleSuperCall"],"mappings":";;;;;;AAAA,uEAAuE;AACvE,IAAO,EAAE,WAAW,YAAY,CAAC,CAAC;AAClC,IAAO,IAAI,WAAW,QAAQ,CAAC,CAAC;AAIhC;IAA6BA,kCAAmBA;IAC9CA,wBAAYA,EAAsBA,EAAUA,EAAmBA;QAAIC,kBAAMA,EAAEA,CAACA,CAACA;QAAjCA,OAAEA,GAAFA,EAAEA,CAAiBA;IAAeA,CAACA;IAE/ED,kCAASA,GAATA,UAAUA,IAAaA;QACrBE,MAAMA,CAACA,CAACA,IAAIA,CAACA,IAAIA,CAACA,CAACA,CAACA;YAClBA,KAAKA,eAAmBA;gBACtBA,yFAAyFA;gBACzFA,+CAA+CA;gBAC/CA,EAAEA,CAACA,CAACA,IAAIA,CAACA,MAAMA,IAAIA,IAAIA,CAACA,MAAMA,CAACA,IAAIA,KAAKA,qBAAyBA,CAACA,CAACA,CAACA;oBAClEA,MAAMA,CAACA,IAAIA,CAACA,oBAAoBA,CAA4BA,IAAIA,CAACA,MAAMA,CAACA,CAACA;gBAC3EA,CAACA;gBACDA,MAAMA,CAACA,KAAKA,CAACA;YACfA,KAAKA,uBAA2BA;gBAC9BA,EAAEA,CAACA,CAACA,IAAIA,CAACA,WAAWA,CAACA,IAAIA,EAAEA,mBAAuBA,CAACA,CAACA,CAACA,CAACA;oBACpDA,oEAAoEA;oBACpEA,IAAIA,CAACA,IAAIA,CAACA,OAAOA,CAACA,CAACA;gBACrBA,CAACA;gBAACA,IAAIA,CAACA,EAAEA,CAACA,CAACA,IAAIA,CAACA,iBAAiBA,CAACA,IAAIA,CAACA,CAACA,CAACA,CAACA;oBACxCA,IAAIA,CAACA,IAAIA,CAACA,OAAOA,CAACA,CAACA;gBACrBA,CAACA;gBAACA,IAAIA,CAACA,CAACA;oBACNA,IAAIA,CAACA,IAAIA,CAACA,KAAKA,CAACA,CAACA;gBACnBA,CAACA;gBACDA,IAAIA,OAAOA,GAAqBA,IAAIA,CAACA;gBACrCA,EAAEA,CAACA,CAACA,IAAIA,CAACA,EAAEA,CAACA,eAAeA,CAACA,OAAOA,CAACA,CAACA;oBAACA,KAAKA,CAACA;gBAC5CA,IAAIA,CAACA,SAASA,CAACA,OAAOA,CAACA,CAACA;gBACxBA,KAAKA,CAACA;YACRA,KAAKA,wBAA4BA;gBAC/BA,IAAIA,QAAQA,GAAsBA,IAAIA,CAACA;gBACvCA,EAAEA,CAACA,CAACA,IAAIA,CAACA,EAAEA,CAACA,eAAeA,CAACA,QAAQA,CAACA,CAACA;oBAACA,KAAKA,CAACA;gBAC7CA,EAAEA,CAACA,CAACA,IAAIA,CAACA,oBAAoBA,CAACA,QAAQA,CAACA,CAACA;oBAACA,KAAKA,CAACA;gBAC/CA,IAAIA,CAACA,SAASA,CAACA,QAAQA,CAACA,CAACA;gBACzBA,KAAKA,CAACA;YACRA,KAAKA,qBAA0BA;gBAC7BA,IAAIA,CAACA,IAAIA,CAACA,OAAOA,CAACA,CAACA;gBACnBA,KAAKA,CAACA;YACRA;gBACEA,MAAMA,CAACA,KAAKA,CAACA;QACjBA,CAACA;QACDA,MAAMA,CAACA,IAAIA,CAACA;IACdA,CAACA;IAEOF,kCAASA,GAAjBA,UAAkBA,CAAoBA;QACpCG,IAAIA,CAACA,KAAKA,CAACA,CAACA,CAACA,UAAUA,CAACA,CAACA;QACzBA,EAAEA,CAACA,CAACA,CAACA,CAACA,aAAaA,IAAIA,CAACA,CAACA,IAAIA,KAAKA,uBAA2BA,CAACA,CAACA,CAACA;YAC9DA,IAAIA,CAACA,WAAWA,CAACA,CAACA,EAAEA,iDAAiDA,CAACA,CAACA;QACzEA,CAACA;QACDA,IAAIA,CAACA,uBAAuBA,CAACA,CAACA,CAACA,CAACA;QAChCA,IAAIA,CAACA,IAAIA,CAACA,GAAGA,CAACA,CAACA;QACfA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,qBAAqBA,CAACA,CAACA,CAACA,CAACA,CAACA,CAACA;YACnCA,IAAIA,CAACA,SAASA,CAACA,CAACA,CAACA,SAASA,CAACA,CAACA;QAC9BA,CAACA;QACDA,IAAIA,CAACA,IAAIA,CAACA,GAAGA,CAACA,CAACA;IACjBA,CAACA;IAEOH,0CAAiBA,GAAzBA,UAA0BA,IAAaA;QACrCI,MAAMA,CAACA,IAAIA,CAACA,W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CjDA,MAAMA,CAACA;gBACTA,CAACA;gBACDA,oBAAoBA;gBACpBA,EAAEA,CAACA,CAACA,OAAOA,CAACA,IAAIA,CAACA,IAAIA,KAAKA,kCAAsCA,CAACA,CAACA,CAACA;oBACjEA,KAAIA,CAACA,WAAWA,CAACA,OAAOA,EAAEA,mBAAmBA,CAACA,CAACA;oBAC/CA,MAAMA,CAACA;gBACTA,CAACA;gBACDA,IAAIA,GAAGA,GAAgCA,OAAOA,CAACA,IAAIA,CAACA;gBACpDA,EAAEA,CAACA,CAACA,GAAGA,CAACA,UAAUA,CAACA,IAAIA,KAAKA,oBAAyBA,CAACA,CAACA,CAACA;oBACtDA,KAAIA,CAACA,WAAWA,CAACA,OAAOA,EAAEA,mBAAmBA,CAACA,CAACA;oBAC/CA,MAAMA,CAACA;gBACTA,CAACA;gBACDA,IAAIA,KAAKA,GAAGA,GAAGA,CAACA,IAAIA,CAACA;gBACrBA,OAAOA,CAACA,IAAIA,GAAGA,KAAKA,CAACA;gBACrBA,WAAWA,CAACA,IAAIA,CAACA,UAAUA,CAACA,CAACA;YAC/BA,CAACA;QACHA,CAACA,CAACA,CAACA;QAEHA,IAAIA,kBAAkBA,GAAGA,WAAWA,CAACA,MAAMA,GAAGA,CAACA,CAACA;QAChDA,EAAEA,CAACA,CAACA,kBAAkBA,CAACA,CAACA,CAACA;YACvBA,6BAA6BA;YAC7BA,IAAIA,CAACA,IAAIA,CAACA,GAAGA,CAACA,CAACA;YACfA,IAAIA,CAACA,SAASA,CAACA,WAAWA,CAACA,CAACA;QAC9BA,CAACA;QACDA,EAAEA,CAACA,CAACA,SAASA,CAACA,CAACA,CAACA;YACdA,IAAIA,CAACA,IAAIA,CAACA,kBAAkBA,GAAGA,GAAGA,GAAGA,GAAGA,CAACA,CAACA;YAC1CA,IAAIA,CAACA,IAAIA,CAACA,SAASA,CAACA,CAACA;YACrBA,EAAEA,CAACA,CAACA,CAACA,IAAIA,CAACA,qBAAqBA,CAACA,SAASA,CAACA,CAACA,CAACA,CAACA;gBAC3CA,IAAIA,CAACA,SAASA,CAACA,SAASA,CAACA,SAASA,CAACA,CAACA;YACtCA,CAACA;YACDA,IAAIA,CAACA,IAAIA,CAACA,GAAGA,CAACA,CAACA;QACjBA,CAACA;QACDA,EAAEA,CAACA,CAACA,aAAaA,CAACA,CAACA,CAACA;YAClBA,iCAAiCA;YACjCA,IAAIA,CAACA,IAAIA,CAACA,GAAGA,CAACA,CAACA;YACfA,MAAMA,CAACA,IAAIA,EAAGA,sBAAsBA;QACtCA,CAACA,GADaA;QACZA,IAAIA,CAACA,CAACA;YACNA,MAAMA,CAACA,KAAKA,CAACA;QACfA,CAACA;IACHA,CAACA;IAEDP;;;OAGGA;IACKA,6CAAoBA,GAA5BA,UAA6BA,QAA2BA;QACtDQ,EAAEA,CAACA,CAACA,QAAQA,CAACA,UAAUA,CAACA,IAAIA,KAAKA,qBAA0BA,CAACA;YAACA,MAAMA,CAACA,KAAKA,CAACA;QAC1EA,sEAAsEA;YAClEA,QAAQA,GAAGA,QAAQA,CAACA,MAAMA,CAACA;QAC/BA,IAAIA,QAAQA,GAAGA,QAAQA,CAACA,MAAMA,CAACA;QAC/BA,IAAIA,IAAIA,GAAGA,QAAQA,CAACA,MAAMA,CAACA;QAC3BA,EAAEA,CAACA,CAACA,IAAIA,CAACA,IAAIA,KAAKA,qBAAyBA,CAACA,CAACA,CAACA;YAC5CA,IAAIA,CAACA,WAAWA,CAACA,QAAQA,EAAEA,8DAA8DA,CAACA,CAACA;YAC3FA,MAAMA,CAACA,KAAKA,CAACA;QACfA,CAACA;QACDA,IAAIA,CAACA,IAAIA,CAACA,uCAAuCA,CAACA,CAACA;QACnDA,MAAMA,CAACA,IAAIA,CAACA;IACdA,CAACA;IACHR,qBAACA;AAADA,CA5MA,EAA6B,IAAI,CAAC,cAAc,EA4M/C;AAED,iBAAS,cAAc,CAAC","file":"call.js","sourcesContent":["/// <reference path='../node_modules/typescript/bin/typescript.d.ts' />\nimport ts = require('typescript');\nimport base = require('./base');\nimport ts2dart = require('./main');\nimport {FacadeConverter} from \"./facade_converter\";\n\nclass CallTranspiler extends base.TranspilerBase {\n  constructor(tr: ts2dart.Transpiler, private fc: FacadeConverter) { super(tr); }\n\n  visitNode(node: ts.Node): boolean {\n    switch (node.kind) {\n      case ts.SyntaxKind.Block:\n        // This is a bit ugly: to separate Declarations from Calls, this code has to special case\n        // blocks that are actually constructor bodies.\n        if (node.parent && node.parent.kind === ts.SyntaxKind.Constructor) {\n          return this.visitConstructorBody(<ts.ConstructorDeclaration>node.parent);\n        }\n        return false;\n      case ts.SyntaxKind.NewExpression:\n        if (this.hasAncestor(node, ts.SyntaxKind.Decorator)) {\n          // Constructor calls in annotations must be const constructor calls.\n          this.emit('const');\n        } else if (this.isInsideConstExpr(node)) {\n          this.emit('const');\n        } else {\n          this.emit('new');\n        }\n        var newExpr = <ts.NewExpression>node;\n        if (this.fc.maybeHandleCall(newExpr)) break;\n        this.visitCall(newExpr);\n        break;\n      case ts.SyntaxKind.CallExpression:\n        var callExpr = <ts.CallExpression>node;\n        if (this.fc.maybeHandleCall(callExpr)) break;\n        if (this.maybeHandleSuperCall(callExpr)) break;\n        this.visitCall(callExpr);\n        break;\n      case ts.SyntaxKind.SuperKeyword:\n        this.emit('super');\n        break;\n      default:\n        return false;\n    }\n    return true;\n  }\n\n  private visitCall(c: ts.CallExpression) {\n    this.visit(c.expression);\n    if (c.typeArguments && c.kind !== ts.SyntaxKind.NewExpression) {\n      this.reportError(c, 'Type arguments are only supported on new calls.');\n    }\n    this.maybeVisitTypeArguments(c);\n    this.emit('(');\n    if (!this.handleNamedParamsCall(c)) {\n      this.visitList(c.arguments);\n    }\n    this.emit(')');\n  }\n\n  private isInsideConstExpr(node: ts.Node): boolean {\n    return this.isConstCall(\n        <ts.CallExpression>this.getAncestor(node, ts.SyntaxKind.CallExpression));\n  }\n\n  private isConstCall(node: ts.CallExpression): boolean {\n    // TODO: Align with facade_converter.ts\n    return node && base.ident(node.expression) === 'CONST_EXPR';\n  }\n\n  private handleNamedParamsCall(c: ts.CallExpression): boolean {\n    // Preamble: This is all committed in the name of backwards compat with the traceur transpiler.\n\n    // Terrible hack: transform foo(a, b, {c: d}) into foo(a, b, c: d), which is Dart's calling\n    // syntax for named/optional parameters. An alternative would be to transform the method\n    // declaration to take a plain object literal and destructure in the method, but then client\n    // code written against Dart wouldn't get nice named parameters.\n    if (c.arguments.length === 0) return false;\n    var last = c.arguments[c.arguments.length - 1];\n    if (last.kind !== ts.SyntaxKind.ObjectLiteralExpression) return false;\n    var objLit = <ts.ObjectLiteralExpression>last;\n    if (objLit.properties.length === 0) return false;\n    // Even worse: foo(a, b, {'c': d}) is considered to *not* be a named parameters call.\n    var hasNonPropAssignments = objLit.properties.some(\n        (p) => (p.kind != ts.SyntaxKind.PropertyAssignment ||\n                (<ts.PropertyAssignment>p).name.kind !== ts.SyntaxKind.Identifier));\n    if (hasNonPropAssignments) return false;\n\n    var len = c.arguments.length - 1;\n    this.visitList(c.arguments.slice(0, len));\n    if (len) this.emit(',');\n    var props = objLit.properties;\n    for (var i = 0; i < props.length; i++) {\n      var prop = <ts.PropertyAssignment>props[i];\n      this.emit(base.ident(prop.name));\n      this.emit(':');\n      this.visit(prop.initializer);\n      if (i < objLit.properties.length - 1) this.emit(',');\n    }\n    return true;\n  }\n\n  /**\n   * Handles constructor initializer lists and bodies.\n   *\n   * <p>Dart's super() ctor calls have to be moved to the constructors initializer list, and `const`\n   * constructors must be completely empty, only assigning into fields through the initializer list.\n   * The code below finds super() calls and handles const constructors, marked with the special\n   * `@CONST` annotation on the class.\n   *\n   * <p>Not emitting super() calls when traversing the ctor body is handled by maybeHandleSuperCall\n   * below.\n   */\n  private visitConstructorBody(ctor: ts.ConstructorDeclaration): boolean {\n    var body = ctor.body;\n    if (!body) return false;\n\n    var errorAssignmentsSuper = 'const constructors can only contain assignments and super calls';\n    var errorThisAssignment = 'assignments in const constructors must assign into this.';\n\n    var parent = <base.ClassLike>ctor.parent;\n    var parentIsConst = this.isConst(parent);\n    var superCall: ts.CallExpression;\n    var expressions: ts.Expression[] = [];\n    // Find super() calls and (if in a const ctor) collect assignment expressions (not statements!)\n    body.statements.forEach((stmt) => {\n      if (stmt.kind !== ts.SyntaxKind.ExpressionStatement) {\n        if (parentIsConst) this.reportError(stmt, errorAssignmentsSuper);\n        return;\n      }\n      var nestedExpr = (<ts.ExpressionStatement>stmt).expression;\n\n      // super() call?\n      if (nestedExpr.kind === ts.SyntaxKind.CallExpression) {\n        var callExpr = <ts.CallExpression>nestedExpr;\n        if (callExpr.expression.kind !== ts.SyntaxKind.SuperKeyword) {\n          if (parentIsConst) this.reportError(stmt, errorAssignmentsSuper);\n          return;\n        }\n        superCall = callExpr;\n        return;\n      }\n\n      // this.x assignment?\n      if (parentIsConst) {\n        // Check for assignment.\n        if (nestedExpr.kind !== ts.SyntaxKind.BinaryExpression) {\n          this.reportError(nestedExpr, errorAssignmentsSuper);\n          return;\n        }\n        var binExpr = <ts.BinaryExpression>nestedExpr;\n        if (binExpr.operatorToken.kind !== ts.SyntaxKind.EqualsToken) {\n          this.reportError(binExpr, errorAssignmentsSuper);\n          return;\n        }\n        // Check for 'this.'\n        if (binExpr.left.kind !== ts.SyntaxKind.PropertyAccessExpression) {\n          this.reportError(binExpr, errorThisAssignment);\n          return;\n        }\n        var lhs = <ts.PropertyAccessExpression>binExpr.left;\n        if (lhs.expression.kind !== ts.SyntaxKind.ThisKeyword) {\n          this.reportError(binExpr, errorThisAssignment);\n          return;\n        }\n        var ident = lhs.name;\n        binExpr.left = ident;\n        expressions.push(nestedExpr);\n      }\n    });\n\n    var hasInitializerExpr = expressions.length > 0;\n    if (hasInitializerExpr) {\n      // Write out the assignments.\n      this.emit(':');\n      this.visitList(expressions);\n    }\n    if (superCall) {\n      this.emit(hasInitializerExpr ? ',' : ':');\n      this.emit('super (');\n      if (!this.handleNamedParamsCall(superCall)) {\n        this.visitList(superCall.arguments);\n      }\n      this.emit(')');\n    }\n    if (parentIsConst) {\n      // Const ctors don't have bodies.\n      this.emit(';');\n      return true;  // completely handled.\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Checks whether `callExpr` is a super() call that should be ignored because it was already\n   * handled by `maybeEmitSuperInitializer` above.\n   */\n  private maybeHandleSuperCall(callExpr: ts.CallExpression): boolean {\n    if (callExpr.expression.kind !== ts.SyntaxKind.SuperKeyword) return false;\n    // Sanity check that there was indeed a ctor directly above this call.\n    var exprStmt = callExpr.parent;\n    var ctorBody = exprStmt.parent;\n    var ctor = ctorBody.parent;\n    if (ctor.kind !== ts.SyntaxKind.Constructor) {\n      this.reportError(callExpr, 'super calls must be immediate children of their constructors');\n      return false;\n    }\n    this.emit('/* super call moved to initializer */');\n    return true;\n  }\n}\n\nexport = CallTranspiler;"],"sourceRoot":"/source/"}