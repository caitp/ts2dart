{"version":3,"sources":["expression.ts"],"names":["ExpressionTranspiler","ExpressionTranspiler.constructor","ExpressionTranspiler.visitNode"],"mappings":"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","file":"expression.js","sourcesContent":["/// <reference path='../node_modules/typescript/bin/typescript.d.ts' />\nimport ts = require('typescript');\nimport base = require('./base');\nimport ts2dart = require('./main');\nimport {FacadeConverter} from './facade_converter';\n\nclass ExpressionTranspiler extends base.TranspilerBase {\n  constructor(tr: ts2dart.Transpiler, private fc: FacadeConverter) { super(tr); }\n\n  visitNode(node: ts.Node): boolean {\n    switch (node.kind) {\n      case ts.SyntaxKind.BinaryExpression:\n        var binExpr = <ts.BinaryExpression>node;\n        var operatorKind = binExpr.operatorToken.kind;\n        if (operatorKind === ts.SyntaxKind.EqualsEqualsEqualsToken ||\n            operatorKind === ts.SyntaxKind.ExclamationEqualsEqualsToken) {\n          if (operatorKind === ts.SyntaxKind.ExclamationEqualsEqualsToken) this.emit('!');\n          this.emit('identical (');\n          this.visit(binExpr.left);\n          this.emit(',');\n          this.visit(binExpr.right);\n          this.emit(')');\n        } else {\n          this.visit(binExpr.left);\n          if (operatorKind === ts.SyntaxKind.InstanceOfKeyword) {\n            this.emit('is');\n            this.fc.visitTypeName(<ts.Identifier>binExpr.right);\n          } else {\n            this.emit(ts.tokenToString(binExpr.operatorToken.kind));\n            this.visit(binExpr.right);\n          }\n        }\n        break;\n      case ts.SyntaxKind.PrefixUnaryExpression:\n        var prefixUnary = <ts.PrefixUnaryExpression>node;\n        this.emit(ts.tokenToString(prefixUnary.operator));\n        this.visit(prefixUnary.operand);\n        break;\n      case ts.SyntaxKind.PostfixUnaryExpression:\n        var postfixUnary = <ts.PostfixUnaryExpression>node;\n        this.visit(postfixUnary.operand);\n        this.emit(ts.tokenToString(postfixUnary.operator));\n        break;\n      case ts.SyntaxKind.ConditionalExpression:\n        var conditional = <ts.ConditionalExpression>node;\n        this.visit(conditional.condition);\n        this.emit('?');\n        this.visit(conditional.whenTrue);\n        this.emit(':');\n        this.visit(conditional.whenFalse);\n        break;\n      case ts.SyntaxKind.DeleteExpression:\n        this.reportError(node, 'delete operator is unsupported');\n        break;\n      case ts.SyntaxKind.VoidExpression:\n        this.reportError(node, 'void operator is unsupported');\n        break;\n      case ts.SyntaxKind.TypeOfExpression:\n        this.reportError(node, 'typeof operator is unsupported');\n        break;\n\n      case ts.SyntaxKind.ParenthesizedExpression:\n        var parenExpr = <ts.ParenthesizedExpression>node;\n        this.emit('(');\n        this.visit(parenExpr.expression);\n        this.emit(')');\n        break;\n\n      case ts.SyntaxKind.PropertyAccessExpression:\n        var propAccess = <ts.PropertyAccessExpression>node;\n        if (propAccess.name.text === 'stack' &&\n            this.hasAncestor(propAccess, ts.SyntaxKind.CatchClause)) {\n          // Handle `e.stack` accesses in catch clauses by mangling to `e_stack`.\n          // FIXME: Use type checker/FacadeConverter to make sure this is actually Error.stack.\n          this.visit(propAccess.expression);\n          this.emitNoSpace('_stack');\n        } else {\n          if (this.fc.handlePropertyAccess(propAccess)) break;\n          this.visit(propAccess.expression);\n          this.emit('.');\n          this.visit(propAccess.name);\n        }\n        break;\n      case ts.SyntaxKind.ElementAccessExpression:\n        var elemAccess = <ts.ElementAccessExpression>node;\n        this.visit(elemAccess.expression);\n        this.emit('[');\n        this.visit(elemAccess.argumentExpression);\n        this.emit(']');\n        break;\n\n      default:\n        return false;\n    }\n    return true;\n  }\n}\n\nexport = ExpressionTranspiler;\n"],"sourceRoot":"/source/"}